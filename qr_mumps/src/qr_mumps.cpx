"""
This is the interface to qr_mumps 

"""

from cpython.string cimport PyString_AsString

from libc.stdint cimport int64_t
from libc.string cimport strncpy, memcpy

import numpy as np
cimport numpy as cnp

cnp.import_array()

import time

{% if type in complex_list %}
cdef extern from "complex.h":
    pass
{% endif %}

cdef extern from "@type|numpy_to_qr_mumps_type@qrm_mumps.h":
    cdef struct @type|numpy_to_qr_mumps_type@qrm_spmat_type_c:
        int          *irn
        int          *jcn
        @type|numpy_to_c@ *val
        int          m, n, nz
        int          *cperm_in
        int          icntl[20]
        double       rcntl[10]
        long int     gstats[10]
        int          h
    
    
    cdef double qrm_swtime();
    cdef void @type|numpy_to_qr_mumps_type@qrm_spmat_init_c(@type|numpy_to_qr_mumps_type@qrm_spmat_type_c *qrm_spmat_c);
    cdef void @type|numpy_to_qr_mumps_type@qrm_spmat_destroy_c(@type|numpy_to_qr_mumps_type@qrm_spmat_type_c *qrm_spmat_c);
    cdef void @type|numpy_to_qr_mumps_type@qrm_readmat_c(char *matfile, @type|numpy_to_qr_mumps_type@qrm_spmat_type_c *qrm_spmat_c);
    cdef void @type|numpy_to_qr_mumps_type@qrm_analyse_c(@type|numpy_to_qr_mumps_type@qrm_spmat_type_c *qrm_spmat_c, const char transp);
    cdef void @type|numpy_to_qr_mumps_type@qrm_factorize_c(@type|numpy_to_qr_mumps_type@qrm_spmat_type_c *qrm_spmat_c, const char transp);
    cdef void @type|numpy_to_qr_mumps_type@qrm_solve_c(@type|numpy_to_qr_mumps_type@qrm_spmat_type_c *qrm_spmat_c, const char transp,
                          @type|numpy_to_c@ *b, @type|numpy_to_c@ *x, const int nrhs);
    cdef void @type|numpy_to_qr_mumps_type@qrm_apply_c(@type|numpy_to_qr_mumps_type@qrm_spmat_type_c *qrm_spmat_c, const char transp,
                          @type|numpy_to_c@ *b, const int nrhs);
    cdef void @type|numpy_to_qr_mumps_type@qrm_matmul_c(@type|numpy_to_qr_mumps_type@qrm_spmat_type_c *qrm_spmat_c, const char transp,
                          const @type|numpy_to_c@ alpha, @type|numpy_to_c@ *x, 
                          const @type|numpy_to_c@ beta, @type|numpy_to_c@ *y, 
                          const int nrhs);
    cdef void @type|numpy_to_qr_mumps_type@qrm_matnrm_c(@type|numpy_to_qr_mumps_type@qrm_spmat_type_c *qrm_spmat_c, const char ntype, 
                          @type|numpy_to_c_single_double@ *nrm);
    cdef void @type|numpy_to_qr_mumps_type@qrm_vecnrm_c(const @type|numpy_to_c@ *x, const int n, const int nrhs, 
                          const char ntype, @type|numpy_to_c_single_double@ *nrm);
    cdef void @type|numpy_to_qr_mumps_type@qrm_least_squares_c(@type|numpy_to_qr_mumps_type@qrm_spmat_type_c *qrm_spmat_c, @type|numpy_to_c@ *b, 
                          @type|numpy_to_c@ *x, const int nrhs);
    cdef void @type|numpy_to_qr_mumps_type@qrm_min_norm_c(@type|numpy_to_qr_mumps_type@qrm_spmat_type_c *qrm_spmat_c, @type|numpy_to_c@ *b, 
                                  @type|numpy_to_c@ *x, const int nrhs);
    cdef void @type|numpy_to_qr_mumps_type@qrm_residual_norm_c(@type|numpy_to_qr_mumps_type@qrm_spmat_type_c *qrm_spmat_c, @type|numpy_to_c@ *b, 
                                  @type|numpy_to_c@ *x, const int nrhs, @type|numpy_to_c_single_double@ *nrm);
    cdef void @type|numpy_to_qr_mumps_type@qrm_residual_orth_c(@type|numpy_to_qr_mumps_type@qrm_spmat_type_c *qrm_spmat_c, @type|numpy_to_c@ *r, 
                                  const int nrhs, @type|numpy_to_c_single_double@ *nrm);
    
    cdef void qrm_gseti_c(const char *string, int val);
    cdef void qrm_ggeti_c(const char *string, int *val);
    cdef void qrm_ggetii_c(const char *string, long long *val);
    
    cdef void @type|numpy_to_qr_mumps_type@qrm_pseti_c(@type|numpy_to_qr_mumps_type@qrm_spmat_type_c *qrm_spmat_c, const char *string, int val);
    cdef void @type|numpy_to_qr_mumps_type@qrm_pgeti_c(@type|numpy_to_qr_mumps_type@qrm_spmat_type_c *qrm_spmat_c, const char *string, int *val);
    cdef void @type|numpy_to_qr_mumps_type@qrm_pgetii_c(@type|numpy_to_qr_mumps_type@qrm_spmat_type_c *qrm_spmat_c, const char *string, long long *val);
    cdef void qrm_err_check_c();
    
    cdef enum icntl:
        qrm_ordering_
        qrm_sing_
        qrm_minamalg_
        qrm_nb_
        qrm_keeph_
        qrm_ib_
        qrm_rhsnb_
        qrm_rhsnthreads_
    
    cdef enum rcntl:
        qrm_amalgthr_
    
    cdef enum ords:
        qrm_auto=0
        qrm_natural_=1
        qrm_given_=2
        qrm_colamd_=3
        qrm_metis_=4
        qrm_scotch_=5
    
    cdef enum gstats:
        qrm_e_facto_flops_=0
        qrm_e_nnz_r_=1
        qrm_e_nnz_h_=2
        qrm_facto_flops_=3
        qrm_nnz_r_=4
        qrm_nnz_h_=5
    
    cdef enum yn:
        qrm_no_=0
        qrm_yes_=1
    

cdef c_to_fortran_index_array(@index|numpy_to_c@ * a, @index|numpy_to_c@ a_size):
    cdef:
        @index|numpy_to_c@ i

    for i from 0 <= i < a_size:
        a[i] += 1

# QR_MUMPS SOLVER
cdef class BaseQRMUMPSSolver_@index@_@type@:
    """
    Base QR_MUMPS Context.

    This version **only** deals with pointers.

    We follow the common use of QR_MUMPS. In particular, we use the same names for
    the methods of this class as their corresponding counter-parts in QR_MUMPS.
    """

    def __cinit__(self, @index|numpy_to_c@ m, @index|numpy_to_c@ n, @index|numpy_to_c@ nnz, verbose=False):
        """
        Args:
            m: number of lines of matrix A
            n: number of columns of matrix A
            nnz: number of nonzeros of matrix A
            verbose: a boolean to turn on or off the verbosity of MUMPS
        """
        self.nrow = m
        self.ncol = n
        self.nnz = nnz

        # Initialize QR_MUMPS internal structure 
        @type|numpy_to_qr_mumps_type@qrm_spmat_init_c(&self.params)

        self.params.m = self.nrow
        self.params.n = self.ncol
        self.params.nz = self.nnz
 
        if m < n:
            self.transp = 't' # True
        else:
            self.transp = 'n' # False

        self.analyzed = False
        self.factorized = False
        qrm_gseti_c(PyString_AsString("qrm_eunit"), 6)
        qrm_gseti_c(PyString_AsString("qrm_ounit"), 6)

        if not verbose:
            self.set_silent()


    cdef index_to_fortran(self):
        """
        Convert 0-based indices to Fortran indices (1-based).

        Note:
          Only for ``irn`` and ``jcn``.
        """

        # transform c index arrays to fortran arrays
        c_to_fortran_index_array(self.params.irn, self.nnz)
        c_to_fortran_index_array(self.params.jcn, self.nnz)


    def __dealloc__(self):
        # autodestruct qr_mumps internal
        @type|numpy_to_qr_mumps_type@qrm_spmat_destroy_c(&self.params)

    # Properties
    property analyzed:
        def __get__(self): return self.analyzed
    property factorized:
        def __get__(self): return self.factorized
    property m:
        def __get__(self): return self.nrow
    property n:
        def __get__(self): return self.ncol
    property nnz:
        def __get__(self): return self.nnz


    def set_silent(self):
        """
        Silence **all** QR_MUMPS output.
        """
        qrm_gseti_c("qrm_ounit", 0)


    def analyze(self, ordering='auto'):
        """
        Performs analysis step of QR_MUMPS.

        TODO: ordering
        """
        if self.analyzed:
            return

        t1 = time.clock()
        @type|numpy_to_qr_mumps_type@qrm_analyse_c(&self.params, self.transp)
        t2 = time.clock()

        self.analyzed = True

        # self.analysis_stats = AnalysisStatistics(self.params,
        #                                          t2 - t1)

    def factorize(self, ordering='auto', pivot_tol=0.01):
        """
        Perform the QR factorization of the matrix A or A'.

        This factorization can then later be used to solve a linear system
        with `solve`. Statistical data of the factorization is stored in
        `factor_stats`.

        Args:
            ordering : { 'auto', 'amd', 'amf', 'scotch', 'pord', 'metis', 'qamd' }
                ordering to use in the factorization. The availability of a
                particular ordering depends on the MUMPS installation.  Default is
                'auto'.
            pivot_tol: number in the range [0, 1]
                pivoting threshold. Pivoting is typically limited in sparse
                solvers, as too much pivoting destroys sparsity. 1.0 means full
                pivoting, whereas 0.0 means no pivoting. Default is 0.01.
        """
        # TODO: ordering

        # Analysis phase must be done before factorization
        if not self.analyzed :
            self.analyze(ordering=ordering)

        @type|numpy_to_qr_mumps_type@qrm_factorize_c(&self.params, self.transp)
        self.factorized = True
        # self.factorize_stats = FactorizationStatistics(self.params, t2 - t1)

    def solve(self, rhs):
        """
        Args:
            rhs: dense NumPy array (matrix or vector).

        Returns:
            Dense NumPy array ``x`` (matrix or vector) with the solution(s) of the linear system.

        Warning: eventough it is written in qr_mumps doc that it is possible to solve the system for multiple
        right-hand-side, I can't make it work!
        """
        if rhs.dtype != np.@type|lower@:
            raise TypeError("Type mismatch! Right hand side must be of type @type@")

        if not self.factorized:
            self.factorize()

        b = np.asfortranarray(rhs.copy())

        # test number of columns in rhs
        rhs_shape = rhs.shape
        if rhs.ndim==1:
            nrhs = 1 
            x = np.zeros(self.ncol, dtype=np.@type|lower@) 
        elif rhs.ndim==2:
            nrhs = rhs_shape[1]
            x = np.zeros([self.ncol, nrhs], order='F', dtype=np.@type|lower@)
        else:
            raise ValueError("Not implemented for 3 dimensional right-hand sides!")

        # Check on right-hand side number of lines
        if (rhs_shape[0] != self.nrow):
            raise ValueError("Right hand side has wrong size.\n"
                             "Attempting to solve the linear system, where A is of size (%d, %d) "
                             "and rhs is of size (%d,%d)"%(self.nrow, self.ncol, rhs_shape[0], nrhs))

        if self.transp=='n':
            @type|numpy_to_qr_mumps_type@qrm_apply_c(&self.params, 't', <@type|numpy_to_c@ *> cnp.PyArray_DATA(b), nrhs);
            @type|numpy_to_qr_mumps_type@qrm_solve_c(&self.params, 'n', <@type|numpy_to_c@ *> cnp.PyArray_DATA(b), <@type|numpy_to_c@ *> cnp.PyArray_DATA(x), nrhs);
        elif self.transp=='t':
            @type|numpy_to_qr_mumps_type@qrm_solve_c(&self.params, 't', <@type|numpy_to_c@ *> cnp.PyArray_DATA(b), <@type|numpy_to_c@ *> cnp.PyArray_DATA(x), nrhs);
            @type|numpy_to_qr_mumps_type@qrm_apply_c(&self.params, 'n', <@type|numpy_to_c@ *> cnp.PyArray_DATA(x), nrhs);
        return x


    def least_squares(self, rhs):
        if self.m < self.n:
            raise RuntimeError("least_squares method can only be called for matrix A with more lines than columns")

        b = np.asfortranarray(rhs.copy())

        # test number of columns in rhs
        rhs_shape = rhs.shape
        if rhs.ndim==1:
            nrhs = 1 
            x = np.zeros(self.ncol, dtype=np.@type|lower@) 
        elif rhs.ndim==2:
            nrhs = rhs_shape[1]
            x = np.zeros([self.ncol, nrhs], order='F', dtype=np.@type|lower@)
        else:
            raise ValueError("Not implemented for 3 dimensional right-hand sides!")

        # Check on right-hand side number of lines
        if (rhs_shape[0] != self.nrow):
            raise ValueError("Right hand side has wrong size.\n"
                             "Attempting to solve the linear system, where A is of size (%d, %d) "
                             "and rhs is of size (%d,%d)"%(self.nrow, self.ncol, rhs_shape[0], nrhs))

        @type|numpy_to_qr_mumps_type@qrm_least_squares_c(&self.params, <@type|numpy_to_c@ *> cnp.PyArray_DATA(b), <@type|numpy_to_c@ *> cnp.PyArray_DATA(x), nrhs)
        return x

    def minimum_norm(self, rhs):
        if self.m >= self.n:
            raise RuntimeError("minimum_norm method can only be called for matrix A with more columns than lines")

        b = np.asfortranarray(rhs.copy())

        # test number of columns in rhs
        rhs_shape = rhs.shape
        if rhs.ndim==1:
            nrhs = 1 
            x = np.zeros(self.ncol, dtype=np.@type|lower@) 
        elif rhs.ndim==2:
            nrhs = rhs_shape[1]
            x = np.zeros([self.ncol, nrhs], order='F', dtype=np.@type|lower@)
        else:
            raise ValueError("Not implemented for 3 dimensional right-hand sides!")

        # Check on right-hand side number of lines
        if (rhs_shape[0] != self.nrow):
            raise ValueError("Right hand side has wrong size.\n"
                             "Attempting to solve the linear system, where A is of size (%d, %d) "
                             "and rhs is of size (%d,%d)"%(self.nrow, self.ncol, rhs_shape[0], nrhs))

        @type|numpy_to_qr_mumps_type@qrm_min_norm_c(&self.params, <@type|numpy_to_c@ *> cnp.PyArray_DATA(b), <@type|numpy_to_c@ *> cnp.PyArray_DATA(x), nrhs)
        return x

